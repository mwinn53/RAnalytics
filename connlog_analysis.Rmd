---
title: "BroConn"
author: "Michael Winn"
date: "October 21, 2016"
output: html_document
---

```{r parseinput, echo = FALSE, message = FALSE, warning = FALSE}

    knitr::opts_chunk$set(fig.width=10, 
                   fig.height=5,
                   echo=FALSE,
                   warning=FALSE)
    rm(list = ls())
     
    require(ggplot2)
    require(psych)
    require(scatterplot3d)
    require(dplyr)
    require(igraph)
    require(gdata)

    files <- list.files(path=".", pattern="*.txt")

    data <- lapply(files, read.csv, sep="\t", header=TRUE, stringsAsFactor = FALSE)
    data <- do.call("rbind", data)

    tm_from <- format(as.POSIXlt(min(data$ts), origin = "1970-01-01"), "%d-%b-%Y %H:%M:%S")
    tm_to <- format(as.POSIXlt(max(data$ts), origin = "1970-01-01"), "%d-%b-%Y %H:%M:%S")
    tm_duration <- as.POSIXct(max(data$ts), origin = "1970-01-01") - as.POSIXct(min(data$ts), origin = "1970-01-01")
    
    num_nodes <- length(nodes$IP)
    num_conn <- length(edges$id.orig_h)
    
    data$proto <- as.factor(data$proto)
    # data$vlan <- as.factor(data$vlan)
    
    data$orig_bytes <- as.numeric(data$orig_bytes)
    data$orig_bytes[is.na(data$orig_bytes)] <- 0
    
    data$resp_bytes <- as.numeric(data$resp_bytes)
    data$resp_bytes[is.na(data$resp_bytes)] <- 0
    
    data$total_bytes <- data$orig_bytes + data$resp_bytes
    
    
    
    
```


```{r networkdata, echo = FALSE, message = FALSE, warning = FALSE}
    ### Build edge list
    temp <- select(data, id.orig_h, id.resp_h, proto, total_bytes, duration, vlan, service)

      
    edges <- summarise(group_by(temp, id.orig_h, id.resp_h, vlan, proto, service), total_bytes = sum(total_bytes))
      edges$vlan <- as.factor(edges$vlan)
      edges$service <- as.factor(edges$service)
      edges <- subset(edges, !is.na(total_bytes))
      edges$width <- as.integer(with(edges,
                                     cut(total_bytes,
                                         breaks = quantile(total_bytes, probs = 1:10/10))),
                                na.rm = TRUE, include.lowest = TRUE)

      edges$width[is.na(edges$width)] <- 1

        
    ### Build vertex list: combine all unique source IPs and dest IPs with a total of combined occurrences
    temp <- select(data, id.orig_h, id.resp_h)
    
    O <-  arrange(count(temp, id.orig_h), desc(n))
    O$id.orig_h <- as.character(O$id.orig_h)
    
    R <- arrange(count(temp, id.resp_h), desc(n))
    R$id.resp_h <- as.character(R$id.resp_h)
    
    names(O) <- c("src", "n")
    names(R) <- c("src", "n")
    
    nodes <- rbind(O, R)
    nodes <- aggregate(n ~ src, data = nodes, FUN = sum)
    
    names(nodes) <- c("IP", "total_conn")

    # Embed the vertex.size attribute as a function of quantiles (width = 10) of total connections
    # nodes$vsize <- as.integer(with(nodes, 
    #                                cut(total_conn, 
    #                                    breaks = quantile(total_conn, probs = 0:10/10))), 
    #                           na.rm = TRUE, include.lowest = TRUE)
    # nodes$vsize[is.na(nodes$vsize)] <- 1
    # nodes <- mutate(nodes, vsize = ifelse(vsize < 1, 1, vsize))
    
    # Cleanup and diagnostics
    rm(O)
    rm(R)
    rm(temp)
    
    head(arrange(nodes, desc(total_conn)))
```


Initial analysis of the logs contained in `r files` 
covered a period of time from `r tm_from` 
to `r tm_to`
(`r tm_duration`). 
During that time period, there were `r num_nodes` 
unique nodes with `r num_conn` unique connections.
There are `r length(unique((data$vlan))` unique VLANs identified

`r round(sum(data$missed_bytes)/sum(data$total_bytes)*100, 2)`% packet loss


```{r summary, echo = FALSE, message = FALSE, warning = FALSE}

  gg <- ggplot(data, aes(x=as.factor(vlan))) +
    geom_bar(stat = "count") +
    labs(x = "VLAN ID", y = "Frequency") +
    ggtitle("VLAN Density")
    
```


```{r networkgraph, echo = FALSE, message = FALSE, warning = FALSE}

    ### Build the graph
    
    colrs <- rainbow(length(levels(as.factor(edges$proto))))
    edges$colors <- colrs[as.factor(edges$proto)]
    
    g <- graph_from_data_frame(d = edges, vertices = nodes, directed = TRUE) # Builds the basic igraph object
    
    # l <- layout_randomly(g)
    # l <- layout_nicely(g)
    # l <- layout_on_grid(g)
    # l <- layout_on_sphere(g)
    l <- layout_with_fr(g)
    # l <- layout_with_kk(g)
    # l <- layout_with_mds(g)
    # l <- layout_with_drl(g)
    # l <- layout_with_lgl(g)
    # l <- layout_with_dh(g)
    # l <- layout_with_fr(g)
    
    l <- norm_coords(l, ymin = -10, ymax = 10, xmin = -10, xmax = 10)
    
    par(mfrow = c(1, 1), mar = c(0, 0, 0, 0))

    plot(g,                                     # Configures the aesthetics of the plot
       # vertex.size =  as.integer(V(g)$vsize),   # Vertex size is a function of the total number of connections
       vertex.size = coreness(g),
       vertex.label = V(g)$name,                # Vertex name should be the node name (IP address)
       # vertex.label.family = "Times",
       vertex.label.cex = .75,
       vertex.label.degree = 1,
       # vertex.shape = "pie",
       edge.width = E(g)$width*0.5,                 # Edge weight is a function of the number of bytes transferred
       edge.color = E(g)$colors,                # Edge color is a protocol (ICMP, TCP, UDP)
       # edge.color = E(g)$vlan,                # Edge color is a protocol (ICMP, TCP, UDP)
       edge.arrow.size =  E(g)$width*0.1,
       edge.curved = TRUE, 
       layout = l
       )
    
    legend(x = -1, 
           y = -.9, 
           c("icmp", "tcp", "udp"),
           pch = 21, 
           col = "#777777", 
           pt.bg = colrs, 
           pt.cex = 2, 
           cex = .8,
           bty = "n",
           ncol = 1
           )
```

```{r networkgraph_byproto echo = FALSE, message = FALSE, warning = FALSE}

    par(mfrow = c(1, 3), mar = c(0, 0, 0, 0))
  
    # protos = as.factor(levels(data$proto))
    
    for(prot in levels(data$proto)) {
      
      ### Build edge list
      temp <- subset(select(data, 
                            id.orig_h, 
                            id.resp_h, 
                            proto, 
                            orig_bytes, 
                            resp_bytes, 
                            duration, 
                            vlan, 
                            service),
                     proto == prot)
      
        temp$orig_bytes <- as.numeric(temp$orig_bytes)
        temp$resp_bytes <- as.numeric(temp$resp_bytes)
        temp$total_bytes <- temp$orig_bytes + temp$resp_bytes
      
    e <- summarise(group_by(temp, id.orig_h, id.resp_h, vlan, proto, service), total_bytes = sum(total_bytes))
      
      e <- subset(e, !is.na(total_bytes))
    
      e$width <- e$total_bytes/sum(e$total_bytes)*100
      e$width[is.na(e$width)] <- 1
      
      e$proto <- as.factor(e$proto)
    
    colrs <- rainbow(length(levels(as.factor(edges$service))))
    e$colors <- colrs[as.factor(e$service)]        
  
      h <- graph_from_data_frame(d = e,
                                 vertices = nodes, 
                                 directed = TRUE) 
      
      h <- delete_vertices(h, degree(h) == 0)
  
      l <- layout_with_fr(h)
    
      plot(h,                                     # Configures the aesthetics of the plot
         # vertex.size =  as.integer(V(g)$vsize),   # Vertex size is a function of the total number of connections
         vertex.size = coreness(h)*2,
         vertex.label = V(h)$name,                # Vertex name should be the node name (IP address)
         # vertex.label.family = "Times",
         vertex.label.cex = .75,
         vertex.label.degree = 1,
         # vertex.shape = "pie",
         edge.width = E(h)$width*0.5,                 # Edge weight is a function of the number of bytes transferred
         edge.color = E(h)$colors,                # Edge color is by service
         edge.arrow.size =  E(h)$width*0.1,
         edge.curved = TRUE,
         layout = l,
         
         # margin = c(1, 1, 1, 1),
         frame = TRUE,
         main = paste("Network graph by Protocol (", prot, ")")
         ) 
      
      legend(x = -1, 
       y = -1, 
       unique(E(h)$service), 
       pch = 21, 
       col = "#777777", 
       pt.bg = colrs, 
       pt.cex = 2, 
       
       cex = .8,
       bty = "n",
       ncol = 1
       )
      
    }
```  
  
```{r graphstats, echo = FALSE, message = FALSE, warning = FALSE}
mean(nodes$total_bytes)
sd(nodes$total_bytes)
mean(edges$total_bytes)
sd(edges$total_bytes)

reciprocity(g)
diameter(g)

hist(degree(g))

```

```{r heatmap, echo = FALSE, message = FALSE, warning = FALSE}
  netm <- get.adjacency(g, attr = "width", sparse = F)
  colnames(netm) <- V(g)$proto
  rownames(netm) <- V(g)$proto
  palf <- colorRampPalette(c("gold", "dark orange"))
  heatmap(netm, Rowv = NA, Colv = NA, col = palf(100), scale = "none", margins = c(10, 10))
```
    
