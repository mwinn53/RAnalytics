---
title: "bro Connection Log Analysis"
author: "Michael Winn"
date: "October 21, 2016"
output: html_document
---

```{r parseInput, echo = FALSE, message = FALSE, warning = FALSE}

    knitr::opts_chunk$set(fig.width=12, 
                   fig.height=8,
                   echo=FALSE,
                   warning=FALSE,
                   options(scipen=999))
    rm(list = ls())
     
    require(ggplot2)
    require(psych)
    require(scatterplot3d)
    require(dplyr)
    require(igraph)
    require(gdata)
    require(reshape2)
    require(scales)
    require(grid)
    
    
    ### READ FILE DATA ###########################################################################
    files <- list.files(path=".", pattern="\\.log$")
    data <- lapply(files, read.csv, sep="\t", header=TRUE, stringsAsFactor = FALSE)
    data <- do.call("rbind", data)

    ### CALCULATE DESCRIPTIVE VARIABLES ##########################################################
    tm_from <- format(as.POSIXlt(min(data$ts), origin = "1970-01-01"), "%d-%b-%Y %H:%M:%S")
    tm_to <- format(as.POSIXlt(max(data$ts), origin = "1970-01-01"), "%d-%b-%Y %H:%M:%S")
    tm_duration <- as.POSIXlt(max(data$ts), origin = "1970-01-01") - as.POSIXlt(min(data$ts), origin = "1970-01-01")

    ### FIX DATA TYPES AND SYNTESIZE MISSING VECTORS #############################################
    data$proto <- as.factor(data$proto)
    data$service[data $service == "-"] <- "UNK"
    
    # data$vlan <- as.factor(data$vlan)
    
    # total bytes
    data$orig_bytes <- as.numeric(data$orig_bytes)
      data$orig_bytes[is.na(data$orig_bytes)] <- 0
    
    data$resp_bytes <- as.numeric(data$resp_bytes)
      data$resp_bytes[is.na(data$resp_bytes)] <- 0
    
    data$total_bytes <- data$orig_bytes + data$resp_bytes
    
    # total pkts
    data$orig_pkts <- as.numeric(data$orig_pkts)
      data$orig_pkts[is.na(data$orig_pkts)] <- 0
    
    data$resp_pkts <- as.numeric(data$resp_pkts)
      data$resp_pkts[is.na(data$resp_pkts)] <- 0
    
  
    data$total_pkts <- data$orig_pkts + data$resp_pkts

    # total ip_bytes
    data$orig_ip_bytes <- as.numeric(data$orig_ip_bytes)
      data$orig_ip_bytes[is.na(data$orig_ip_bytes)] <- 0
    
    data$resp_ip_bytes <- as.numeric(data$resp_ip_bytes)
      data$resp_ip_bytes[is.na(data$resp_ip_bytes)] <- 0
    
    data$total_ip_bytes <- data$orig_ip_bytes + data$resp_ip_bytes
    
    ### FUNCTION DECLARATIONS ###########################################################################
    
    ## Function:    summarizeColumns
    #   Purpose:    calculate summary statistics on the columns of a data frame (data)
    #   Input:      Data frame, trimmed to the columns of interest (rows contain data records)
    #   Output:     Data frame -- columns of the input data frame are transposed to rows
    #               columns are n, mean, sd, median, trimmed, mad, min, max, range, skew, kurtosis, std err, 
    #               variance, std error of the mean, and conf interval
    
    summarizeColumns <- function (data, conf.int = .95, rm.nas = FALSE){
      
      if(rm.nas == TRUE) data <- data[complete.cases(data),]
      
      data$resp_pkts[is.na(data$resp_pkts)] <- 0
      result <- describe(data)
      result$var <- apply(as.matrix(data), 2, FUN = var)
      result$sem <- result$sd / sqrt(result$n)
      result$ci <- result$sem * qt((conf.int/2) + .5, result$n-1)
      
      return(result)                      ## Gen
      # return(result[c(2,3,14,4,13,15,16)])  ## Return filtered to n, mean, var, sd, se, sem, and ci
    }
    
    ## Function:    buildEdgeList
    #   Purpose:    Builds an edge list of unique vertices extracted from the connection log
    #   Input:      connLog as a data frame
    #   Output:     data frame  (id.orig_h, id.resp_h, proto, total_bytes, duration, vlan, service) 
    #               of connections between nodes, summarized by total number of bytes.
    buildEdgeList <- function(connlog) {
      ### Build edge list
      
      temp <- select(connlog, id.orig_h, id.resp_h, proto, total_bytes, duration, vlan, service)

      edges <- summarise(group_by(temp, id.orig_h, id.resp_h, vlan, proto, service), total_bytes = sum(total_bytes))
        edges$vlan <- as.factor(edges$vlan)
        edges$service <- as.factor(edges$service)
        edges <- subset(edges, !is.na(total_bytes))
        edges$width <- as.integer(with(edges,
                                       cut(total_bytes,
                                           breaks = quantile(total_bytes, probs = 1:10/10))),
                                  na.rm = TRUE, include.lowest = TRUE)
  
        edges$width[is.na(edges$width)] <- 1
        
      return(edges)
      
    }
    
    ## Function:    buildVertexList
    #   Purpose:    Builds a vertex list of unique vertices extracted from the edge list
    #   Input:      edgeList. A data frame consisting of at least an originator (id.orig_h) 
    #               and responder (id.resp_h) vector
    #   Output:     data frame  (IP, total_conn) of nodes and a count of their total number occcurrences.
    buildVertexList <- function(edgeList) {
      
      edgeList <- ungroup(edgeList)
      
      temp <- select(edgeList, id.orig_h, id.resp_h) 
    
      O <-  arrange(count(temp, id.orig_h), desc(n))
      O$id.orig_h <- as.character(O$id.orig_h)
    
      R <- arrange(count(temp, id.resp_h), desc(n))
      R$id.resp_h <- as.character(R$id.resp_h)
    
      names(O) <- c("src", "n")
      names(R) <- c("src", "n")
    
      nodes <- rbind(O, R)
      nodes <- aggregate(n ~ src, data = nodes, FUN = sum)
    
      names(nodes) <- c("IP", "total_conn")
      
      return(nodes)
    }
    
    ## Lifted from http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_%28ggplot2%29/
    multiplot <- function(..., plotlist = NULL, file, cols = 1, layout = NULL) {
    
      plots <- c(list(...), plotlist)
    
      numPlots = length(plots)
    
      if (is.null(layout)) {
        layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                        ncol = cols, nrow = ceiling(numPlots/cols))
      }
    
      if (numPlots == 1) {
        print(plots[[1]])
    
      } else {
        grid.newpage()
        pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
        for (i in 1:numPlots) {
          matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
    
          print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                          layout.pos.col = matchidx$col))
        }
      }
    }

    
```

# Introduction and Research Questions

1) Can the data set create a visualization of communication flow that informs sensor placement and configuration?

2) Is anamolous communication detectable among the hosts in the given data set?

# Descriptive Summary of Data Set

Initial analysis of the bro connection logs contained in ``r files`` 
covered a period of time from ``r tm_from`` 
to ``r tm_to``
(approximately ``r round(tm_duration, 2)`` hours). 

Summary statistics of the overall data set, followed by lists of the IP Addresses with the Top 10 and Bottom 10 volume of connections is listed below:

```{r networkData, echo = FALSE, message = FALSE, warning = FALSE}
    
  ### Build edge and node lists
    edges <- buildEdgeList(data)
  
    nodes <- buildVertexList(edges)

  ### Calculate additional descriptive variables    
    num_nodes <- length(nodes$IP)
    num_conn <- length(edges$id.orig_h)

    # Embed the vertex.size attribute as a function of quantiles (width = 10) of total connections
    # nodes$vsize <- as.integer(with(nodes, 
    #                                cut(total_conn, 
    #                                    breaks = quantile(total_conn, probs = 0:10/10))), 
    #                           na.rm = TRUE, include.lowest = TRUE)
    # nodes$vsize[is.na(nodes$vsize)] <- 1
    # nodes <- mutate(nodes, vsize = ifelse(vsize < 1, 1, vsize))
    
    summarizeColumns(select(data, 
                            orig_bytes, 
                            resp_bytes, 
                            missed_bytes, 
                            total_bytes, 
                            orig_ip_bytes, 
                            resp_ip_bytes, 
                            total_ip_bytes, 
                            orig_pkts, 
                            resp_pkts, 
                            total_pkts)
                     )[c(2,3,14,4,13,15,16)]
    
    head(arrange(nodes, desc(total_conn)), 10)
    head(arrange(nodes, total_conn), 10)
    
```

During the logging time period, ``r num_nodes`` and unique nodes with ``r num_conn`` unique connections, and a total of ``r as.numeric(sum(data$total_pkts))`` packets (``r humanReadable(sum(data$total_ip_bytes), standard = "SI")``) were caclulated from data recorded in the observed IP headers. The communications contained ``r length(unique(data$service))`` unique services among ``r length(unique(data$proto))`` protocols. Additionally, bro recorded `r length(unique(data$vlan))` unique VLAN tags.

bro measures originator and responder bytes from observed TCP sequence numbers. Missed bytes are also derived from TCP sequence numbers and are used to estimate packet loss. A total of ``r humanReadable(sum(data$total_bytes), standard = "SI")`` were recorded from TCP headers, with ``r humanReadable(sum(data$missed_bytes), standard = "SI")`` missing. The estimated packet loss is approximately ``r round(sum(data$missed_bytes)/sum(data$total_bytes)*100, 1)`%`.

*[TODO] Discussion of the results*

```{r summaryTimeline, echo = FALSE, message = FALSE, warning = FALSE}
  
  bin <- 3600
  d <- select(data, ts, total_pkts)
  d$dattm <- as.POSIXct(d$ts, origin = "1970-01-01")
  
  ggplot(d, aes(dattm)) +
    geom_histogram(binwidth = bin) +
    ggtitle("Hourly Connections") +
    labs(x = "Time", y = "Total Packets") +
    scale_x_datetime(breaks = date_breaks("4 hours"),
                     minor_breaks = date_breaks("1 hour"))
    # scale_y_continuous(trans = log2_trans()) + 
    # coord_trans(y = log2)
  
```

```{r summary, echo = FALSE, message = FALSE, warning = FALSE}
  g1 <- ggplot(data, aes(x=as.factor(vlan))) +
    geom_bar(stat = "count") +
    labs(x = "VLAN ID" , y = "Frequency") +
    ggtitle("Overall VLAN Density") +
    theme(axis.text.x  = element_text(angle=45))
  
  g2 <- ggplot(data, aes(x=as.factor(service))) +
    geom_bar(stat = "count") +
    labs(x = "Service" , y = "Frequency") +
    ggtitle("Overall Service Density") +
    theme(axis.text.x  = element_text(angle=45))

  multiplot(g1, g2, cols = 2)
  
```

* *[TODO] Discussion of the heatmap*
* *[TODO] Interpretation of the dendrograph*

```{r heatmap, echo = FALSE, message = FALSE, warning = FALSE}
  d <- select(data, vlan, service, total_pkts)
  m <- acast(d, vlan ~ service, value.var = "total_pkts")
  h1 <- heatmap(m, col = topo.colors(max(length(unique(data$vlan)), length(unique(data$service)))), main = "Total Packets between VLANs and services", xlab = "service", ylab = "VLAN ID")
  
```
   
# Analysis of Network Traffic

*[TODO] Discussion of the overall network communication picture.* 

Vertices are sized according to the relative volume of connections (inbound and outbound). Edges are directional, and colored by protocol. Edges thicknesses reflect the relative number of bytes transferred.

```{r networkgraph, echo = FALSE, message = FALSE, warning = FALSE}

  ### Build the graph
    colrs <- rainbow(length(levels(as.factor(edges$proto))))
    edges$colors <- colrs[as.factor(edges$proto)]
    
    g <- graph_from_data_frame(d = edges, vertices = nodes, directed = TRUE) # Builds the basic igraph object
    
    # l <- layout_randomly(g)
    # l <- layout_nicely(g)
    # l <- layout_on_grid(g)
    # l <- layout_on_sphere(g)
    l <- layout_with_fr(g)
    # l <- layout_with_kk(g)
    # l <- layout_with_mds(g)
    # l <- layout_with_drl(g)
    # l <- layout_with_lgl(g)
    # l <- layout_with_dh(g)
    # l <- layout_with_fr(g)
    
    l <- norm_coords(l, ymin = -10, ymax = 10, xmin = -10, xmax = 10)
    
    # par(mfrow = c(1, 1), mar = c(0, 0, 0, 0))

    plot(g,                                       # Configures the aesthetics of the plot
       # vertex.size =  as.integer(V(g)$vsize),   # Vertex size is a function of the total number of connections
       vertex.size = coreness(g),
       vertex.label = V(g)$name,                  # Vertex name should be the node name (IP address)
       # vertex.label.family = "Times",
       vertex.label.cex = .75,
       vertex.label.degree = 1,
       # vertex.shape = "pie",
       edge.width = E(g)$width*0.5,               # Edge weight is a function of the number of bytes transferred
       edge.color = E(g)$colors,                  # Edge color is a protocol (ICMP, TCP, UDP)
       # edge.color = E(g)$vlan,                  # Edge color is a VLAN
       edge.arrow.size =  E(g)$width*0.1,
       edge.curved = TRUE, 
       layout = l
       )
    
    legend(x = -1, 
           y = -.9, 
           c("icmp", "tcp", "udp"),
           pch = 21, 
           col = "#777777", 
           pt.bg = colrs, 
           pt.cex = 2, 
           cex = .8,
           bty = "n",
           ncol = 1,
           title = "Protocol"
           )
```

The following graph separates the network communications by protocol (e.g. `r levels(data$proto)`).

*[TODO] Discussion of the overall network communication picture.* 

```{r networkgraph_byproto, echo = FALSE, message = FALSE, warning = FALSE}

    # par(mfrow = c(1, 3), mar = c(0, 0, 0, 0))
  
    for(prot in levels(data$proto)) {
      
      ### Build edge list
      temp <- subset(select(data, 
                            id.orig_h, 
                            id.resp_h, 
                            proto, 
                            orig_bytes, 
                            resp_bytes, 
                            duration, 
                            vlan, 
                            service),
                     proto == prot)
      
        temp$orig_bytes <- as.numeric(temp$orig_bytes)
        temp$resp_bytes <- as.numeric(temp$resp_bytes)
        temp$total_bytes <- temp$orig_bytes + temp$resp_bytes
      
      e <- summarise(group_by(temp, id.orig_h, id.resp_h, vlan, proto, service), total_bytes = sum(total_bytes))
        e <- subset(e, !is.na(total_bytes))
    
      e$width <- e$total_bytes/sum(e$total_bytes)*100
      e$width[is.na(e$width)] <- 1
      
      e$proto <- as.factor(e$proto)
    
    colrs <- rainbow(length(levels(as.factor(edges$service))))
    e$colors <- colrs[as.factor(e$service)]        
  
      h <- graph_from_data_frame(d = e,
                                 vertices = nodes, # use the existing (unmodified) node list...
                                 directed = TRUE) 
      
      h <- delete_vertices(h, degree(h) == 0)     # ...remove nodes that do not have corresponding edges
  
      l <- layout_with_fr(h)
    
      plot(h,                                       # Configures the aesthetics of the plot
         # vertex.size =  as.integer(V(g)$vsize),   # Vertex size is a function of the total number of connections
         vertex.size = coreness(h)*2,
         vertex.label = V(h)$name,                  # Vertex name should be the node name (IP address)
         # vertex.label.family = "Times",
         vertex.label.cex = .75,
         vertex.label.degree = 1,
         # vertex.shape = "pie",
         edge.width = E(h)$width*0.5,               # Edge weight is a function of the number of bytes transferred
         edge.color = E(h)$colors,                  # Edge color is by service (dns, http, ssh, etc.)
         edge.arrow.size =  E(h)$width*0.1,
         edge.curved = TRUE,
         layout = l,
         
        
         frame = FALSE,
         main = paste("Network graph by Protocol (", prot, ")")
         ) 
      
      legend(x = -1, 
       y = -1, 
       unique(E(h)$service), 
       pch = 21, 
       col = "#777777", 
       pt.bg = colrs, 
       pt.cex = 2, 
       
       cex = .8,
       bty = "n",
       ncol = 1,
       title = "Service"
       )
      
    }
```  

## Network Traffic Subgraph 


# TO DO SECTION

```{r graphstats, echo = FALSE, message = FALSE, warning = FALSE}
mean(nodes$total_bytes)
sd(nodes$total_bytes)
mean(edges$total_bytes)
sd(edges$total_bytes)

reciprocity(g)
diameter(g)

hist(degree(g))

```

 
